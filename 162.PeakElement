class Solution {
    public int findPeakElement(int[] nums) {
        /*
        Edge case : 
        The first element and the last element will not have one neighbour and it will be considered at -infinity, resulting to a fact that if they are greater then their existing neighbour, they are peak.

        BRUTE FORCE APPROACH: O(n)
            Simply traverse the array from the 1st index till the last-1 index and compare it to it's neighbouring elements.

        OPTIMIZED APPROACH : O(log n)
        1.Consider the edge cases and then start from the 1st index till the last-1 index, apply binary search and find the mid element.
        2.If the mid element has both its neighbours as smaller, then it is a peak element.
        3.If the left neighbour of mid is greater than mid, meaning that it has a potential of being the peak element, shift the array.
        4.If the right neighbour is greater than mid, meaning that it has a potential of being the peak element, shift the array accordingly
        5.Return the mid once the peak element condition satisfies as we have to return any one of the peak element and not the largest one.
        */

        //Edge case for the first element
        if(nums.length==1) return 0;
        else if(nums[0]>nums[1]){
            return 0;
        }
        //Edge case for the last element
        else if(nums[nums.length-1]>nums[nums.length-2]){
            return nums.length-1;
        }

        int low=1;
        int high=nums.length-2;

        while(low<=high)
        {
            int mid=(low+high)/2;
            if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]){
                return mid;
            }
            else if(nums[mid]<nums[mid-1]){
                high=mid-1;
            }
            else{
                low=mid+1;
            }
        }
        return -1;
    }
}
